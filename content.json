{"meta":{"title":"Tommy的博客","subtitle":"","description":"","author":"tommy","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Lambda与Stream-API","slug":"Lambda与Stream-API","date":"2020-05-30T06:15:40.000Z","updated":"2020-05-30T06:26:08.417Z","comments":true,"path":"2020/05/30/Lambda与Stream-API/","link":"","permalink":"http://yoursite.com/2020/05/30/Lambda%E4%B8%8EStream-API/","excerpt":"","text":"Lambda与Stream-API一、Lambda与函数式编程​ Lambda表达式是Java 8最流行最常用的功能特性。它将函数式编程概念引入Java，函数式编程的好处在于可以帮助我们节省大量的代码，非常方便易用，能够大幅度的提高我们的编码效率。首先，我们介绍lambda表达式是什么，并将传统的java代码写法转换为lambda表达式写法，以此了解lambda表达式都对传统代码做了哪些简化。 看如下两段代码，很清晰的说明了lambda表达式是表达接口函数的实现。在传统的开发中，我们习惯所有的行为定义代码都封装在方法体内，并通过对象引用执行，就像使用下面的代码： 123456789101112public class LambdaDemo &#123; //函数定义 public void printSomething(String something) &#123; System.out.println(something); &#125; //通过创建对象调用函数 public static void main(String[] args) &#123; LambdaDemo demo = new LambdaDemo(); String something = \"I am learning Lambda\"; demo.printSomething(something); &#125;&#125; 下面是将上述代码用Lambda实现,我们使用lambda表达式内联为函数调用参数将最初的9行代码下降到只有3行。 123456public static void main(String[] args) &#123; LambdaDemo demo = new LambdaDemo(); String something=\"I am Lambda\"; //关注下面的这行代码 demo.printSomething(something, toPrint -&gt; System.out.println(toPrint));&#125; 其中以下为lambda表达式： 1demo.printSomething(something, toPrint -&gt; System.out.println(toPrint)); 总结如下： lambda表达式，表达的是接口函数 箭头左侧是函数的逗号分隔的形式参数列表 箭头右侧是函数体代码 lambda表达式表达的是接口函数，箭头左侧是函数参数，箭头右侧是函数体。函数的参数类型和返回值类型都可以省略，程序会根据接口定义的上下文自动确定数据类型。如果将java8 Stream API结合lambda表达式使用，编码效率将会大幅度提高！下面介绍Stream-API。 二、Stream-APIJava Stream函数式编程接口在Java 8中引入，与Lambda使用极大的方便了集合类数据处理的效率。Java Stream就是一个数据流经的管道，并且在管道中对数据进行操作，然后流入下一个管道。管道的功能包括：Filter（过滤）、Map(映射)、sort(排序）等，集合数据通过Java Stream管道处理之后，转化为另一组集合或数据输出。可以处理的对象有数组、集合类、文本文件。具体示意如下图所示： 我们可以先看一个 Stream API代替for循环的例子： 12345678List&lt;String&gt; nameStrs = Arrays.asList(\"zhangsan\", \"lisi\", \"wangwu\",\"zhaoliu\");List&lt;String&gt; list = nameStrs.stream() .filter(s -&gt; s.startsWith(\"L\")) .map(String::toUpperCase) .sorted() .collect(toList());System.out.println(list); 首先，我们使用Stream()函数，将一个List转换为管道流 调用filter函数过滤数组元素，过滤方法使用lambda表达式，以L开头的元素返回true被保留，其他的List元素被过滤掉 然后调用Map函数对管道流中每个元素进行处理，字母全部转换为大写 然后调用sort函数，对管道流中数据进行排序 最后调用collect函数toList，将管道流转换为List返回 最终的输出结果是：[LEMUR, LION]。大家可以想一想，上面的这些对数组进行遍历的代码，如果你用for循环来写，需要写多少行代码? 1)filter与谓语逻辑filter的官方定义如下：![image-20200520143618245](/Users/chengkai/Library/Application Support/typora-user-images/image-20200520143618245.png) 方法说明翻译为：返回一个流，该流包含与给定谓词匹配的该流的元素。由此得知：filter的起过滤作用。过滤的条件为谓词匹配。关于过滤作用我们可以看下面一个例子： 1234//取出年龄大于70岁的男性用户List&lt;User&gt; filtered = users.stream() .filter(e -&gt; e.getAge() &gt; 70 &amp;&amp; e.getGender().equals(\"Man\")) .collect(Collectors.toList()); 其中 e.getAge() &gt; 70 、e.getGender().equals(&quot;Man&quot;)可以在实体中定义为： 123public static Predicate&lt;Employee&gt; getOldEmp = one -&gt; one.getAge()&gt;70;public static Predicate&lt;Employee&gt; getMEmp = emp -&gt; emp.getGender().equals(\"M\"); 上图就是将谓语逻辑的体现。谓语逻辑主要解决的问题是”做什么“、”是什么“或者是”怎么样“。通常情况下，filter函数中lambda表达式为一次性使用的谓词逻辑。如果我们的谓词逻辑需要被多处、多场景、多代码中使用，通常将它抽取出来单独定义到它所限定的主语实体中(如上)。其中谓语逻辑还提供了 and(并集)、or(交集)、negate(取反)语法。 2)map操作Stream提供的map函数不仅可以处理数据、还可以转换数据(对象数据格式装换)的类型、其中当函数没有返回值或者参数就是返回值的时候可以使用peek函数、处理二位数组可以用flatMap。 3)状态与并行操作Stream还提供了一些对状态的操作的方法，之前我们提到的ilter与map操作，还提供了sorted排序操作、distinct去重操作、limit和skip截取操作、Sorted排序。对于大数据量的情况想要提升运行速度，Stream提供了parallel()函数表示对管道中的元素进行并行处理。通常情况下，parallel()能够很好的利用CPU的多核处理器，达到更好的执行效率和性能，建议使用。但是有些特殊的情况下，parallel并不适。 4)Comparator接口与函数式接口说到Comparator接口就要引出一个概念，函数式接口。所谓的函数式接口，实际上就是接口里面只能有一个抽象方法的接口。我们用到的Comparator接口就是一个典型的函数式接口，它只有一个抽象方法compare。 ![image-20200529162918058](/Users/chengkai/Library/Application Support/typora-user-images/image-20200529162918058.png) 如图：函数式接口的特点为： 接口有且仅有一个抽象方法，如上图的抽象方法compare 允许定义静态非抽象方法 允许定义默认defalut非抽象方法（default方法也是java8才有的，见下文） 允许java.lang.Object中的public方法，如上图的方法equals。 FunctionInterface注解不是必须的，如果一个接口符合”函数式接口”定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错 函数式接口是专门为lambda表达式准备的，lambda表达式是只实现接口中唯一的抽象方法的匿名实现类。 JDK中的其他的函数式接口有：java.lang.Runnable、java.util.Comparator、java.util.concurrent.Callable、java.util.function包下的接口，如Consumer、Predicate、Supplier等 5)reduce与集合元素规约Stream API为我们提供了Stream.reduce用来实现集合元素的归约。reduce函数有三个参数： Identity标识：一个元素，它是归约操作的初始值，如果流为空，则为默认结果。 Accumulator累加器：具有两个参数的函数：归约运算的部分结果和流的下一个元素。 Combiner合并器（可选）：当归约并行化时，或当累加器参数的类型与累加器实现的类型不匹配时，用于合并归约操作的部分结果的函数。 6)forEach和终端操作Stream提供了我们对于集合的终端操作，如收集为Set、收集为List、收集到Array、收集为Map、分组收集groupingBy。 我们可以看下面两个例子： 12//将 Employee List 转换为 id-Employee 的mapMap&lt;Integer,Employee&gt; mapNameEmp = empList.stream().collect(Collectors.toMap(Employee::getId, Employee-&gt;Employee,(k1,k2)-&gt;k1)); 123//将用户按照性别分组Map&lt;String,List&lt;Employee&gt;&gt; result = empList.stream().collect(Collectors.groupingBy(Employee :: getGender));System.out.println(JSON.toJSONString(result)); 第一个例子举例了我们的常用操作list转map,第二个例子举例了groupingBy的使用。 7)Stream的性能问：stream比for循环慢5倍，用这个是为了啥？答：互联网是一个新闻泛滥的时代，三人成虎，以假乱真的事情时候发生。作为一个技术开发者，要自己去动手去做，不要人云亦云。 性能测试脱离业务场景就是片面的性能测试，只有你在生产环境下的运行结果才是真的。我们可以动手测试用Junit来测试 Stream的性能。 *测试用例一 * 测试用例：5亿个int随机数，求最小值测试结论： 使用普通for循环，执行效率是Stream串行流的2倍。也就是说普通for循环性能更好。 Stream并行流计算是普通for循环执行效率的4-5倍。 Stream并行流计算 &gt; 普通for循环 &gt; Stream串行流计算 测试用例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657mport com.github.houbb.junitperf.core.annotation.JunitPerfConfig;import com.github.houbb.junitperf.core.report.impl.HtmlReporter;import org.junit.jupiter.api.BeforeAll;import java.util.Arrays;import java.util.Random;public class StreamIntTest &#123; public static int[] arr; @BeforeAll public static void init() &#123; arr = new int[500000000]; //5亿个随机Int randomInt(arr); &#125; @JunitPerfConfig( warmUp = 1000, reporter = &#123;HtmlReporter.class&#125;) public void testIntFor() &#123; minIntFor(arr); &#125; @JunitPerfConfig( warmUp = 1000, reporter = &#123;HtmlReporter.class&#125;) public void testIntParallelStream() &#123; minIntParallelStream(arr); &#125; @JunitPerfConfig( warmUp = 1000, reporter = &#123;HtmlReporter.class&#125;) public void testIntStream() &#123; minIntStream(arr); &#125; private int minIntStream(int[] arr) &#123; return Arrays.stream(arr).min().getAsInt(); &#125; private int minIntParallelStream(int[] arr) &#123; return Arrays.stream(arr).parallel().min().getAsInt(); &#125; private int minIntFor(int[] arr) &#123; int min = Integer.MAX_VALUE; for (int anArr : arr) &#123; if (anArr &lt; min) &#123; min = anArr; &#125; &#125; return min; &#125; private static void randomInt(int[] arr) &#123; Random r = new Random(); for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = r.nextInt(); &#125; &#125;&#125; *测试用例二 * 测试用例：长度为10的1000000随机字符串，求最小值测试结论（测试代码见后文）： 普通for循环执行效率与Stream串行流不相上下 Stream并行流的执行效率远高于普通for循环 Stream并行流计算 &gt; 普通for循环 = Stream串行流计算 测试代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import com.github.houbb.junitperf.core.annotation.JunitPerfConfig;import com.github.houbb.junitperf.core.report.impl.HtmlReporter;import org.junit.jupiter.api.BeforeAll;import java.util.ArrayList;import java.util.Random;public class StreamStringTest &#123; public static ArrayList&lt;String&gt; list; @BeforeAll public static void init() &#123; list = randomStringList(1000000); &#125; @JunitPerfConfig(duration = 10000, warmUp = 1000, reporter = &#123;HtmlReporter.class&#125;) public void testMinStringForLoop()&#123; String minStr = null; boolean first = true; for(String str : list)&#123; if(first)&#123; first = false; minStr = str; &#125; if(minStr.compareTo(str)&gt;0)&#123; minStr = str; &#125; &#125; &#125; @JunitPerfConfig(duration = 10000, warmUp = 1000, reporter = &#123;HtmlReporter.class&#125;) public void textMinStringStream()&#123; list.stream().min(String::compareTo).get(); &#125; @JunitPerfConfig(duration = 10000, warmUp = 1000, reporter = &#123;HtmlReporter.class&#125;) public void testMinStringParallelStream()&#123; list.stream().parallel().min(String::compareTo).get(); &#125; private static ArrayList&lt;String&gt; randomStringList(int listLength)&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(listLength); Random rand = new Random(); int strLength = 10; StringBuilder buf = new StringBuilder(strLength); for(int i=0; i&lt;listLength; i++)&#123; buf.delete(0, buf.length()); for(int j=0; j&lt;strLength; j++)&#123; buf.append((char)('a'+ rand.nextInt(26))); &#125; list.add(buf.toString()); &#125; return list; &#125;&#125; 测试用例三 测试用例：10个用户，每人200个订单。按用户统计订单的总价。测试结论（测试代码见后文）： Stream并行流的执行效率远高于普通for循环 Stream串行流的执行效率大于等于普通for循环 Stream并行流计算 &gt; Stream串行流计算 &gt;= 普通for循环 测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687import com.github.houbb.junitperf.core.annotation.JunitPerfConfig;import com.github.houbb.junitperf.core.report.impl.HtmlReporter;import org.junit.jupiter.api.BeforeAll;import java.util.*;import java.util.stream.Collectors;public class StreamObjectTest &#123; public static List&lt;Order&gt; orders; @BeforeAll public static void init() &#123; orders = Order.genOrders(10); &#125; @JunitPerfConfig(duration = 10000, warmUp = 1000, reporter = &#123;HtmlReporter.class&#125;) public void testSumOrderForLoop()&#123; Map&lt;String, Double&gt; map = new HashMap&lt;&gt;(); for(Order od : orders)&#123; String userName = od.getUserName(); Double v; if((v=map.get(userName)) != null)&#123; map.put(userName, v+od.getPrice()); &#125;else&#123; map.put(userName, od.getPrice()); &#125; &#125; &#125; @JunitPerfConfig(duration = 10000, warmUp = 1000, reporter = &#123;HtmlReporter.class&#125;) public void testSumOrderStream()&#123; orders.stream().collect( Collectors.groupingBy(Order::getUserName, Collectors.summingDouble(Order::getPrice))); &#125; @JunitPerfConfig(duration = 10000, warmUp = 1000, reporter = &#123;HtmlReporter.class&#125;) public void testSumOrderParallelStream()&#123; orders.parallelStream().collect( Collectors.groupingBy(Order::getUserName, Collectors.summingDouble(Order::getPrice))); &#125;&#125;class Order&#123; private String userName; private double price; private long timestamp; public Order(String userName, double price, long timestamp) &#123; this.userName = userName; this.price = price; this.timestamp = timestamp; &#125; public String getUserName() &#123; return userName; &#125; public double getPrice() &#123; return price; &#125; public long getTimestamp() &#123; return timestamp; &#125; public static List&lt;Order&gt; genOrders(int listLength)&#123; ArrayList&lt;Order&gt; list = new ArrayList&lt;&gt;(listLength); Random rand = new Random(); int users = listLength/200;// 200 orders per user users = users==0 ? listLength : users; ArrayList&lt;String&gt; userNames = new ArrayList&lt;&gt;(users); for(int i=0; i&lt;users; i++)&#123; userNames.add(UUID.randomUUID().toString()); &#125; for(int i=0; i&lt;listLength; i++)&#123; double price = rand.nextInt(1000); String userName = userNames.get(rand.nextInt(users)); list.add(new Order(userName, price, System.nanoTime())); &#125; return list; &#125; @Override public String toString()&#123; return userName + \"::\" + price; &#125;&#125; 结论：在大多数的核心业务场景下及常用数据结构下，Stream的执行效率比for循环更高 Stream并行流计算 &gt;&gt; 普通for循环 ~= Stream串行流计算 数据容量越大，Stream流的执行效率越高。 Stream并行流计算通常能够比较好的利用CPU的多核优势。CPU核心越多，Stream并行流计算效率越高。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}],"categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}